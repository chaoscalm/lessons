<html><head><script>var canvas, ctx, texted, output;function init() {    canvas = document.getElementById("canvas")    ctx = canvas.getContext("2d")    texted = document.getElementById("text")    output = document.getElementById("output")    }function textChanged() {    ctx.clearRect(0, 0, canvas.width, canvas.height)    output.innerHTML = ""    ctx.strokeStyle="#FF0000";    text = texted.value    var x = canvas.width / 2    var y = canvas.height / 2    var ang = 0    var ip = 0    var readChars = function(pred) {        var s = "";        var nc = text[ip]        while (ip < text.length && pred(nc)) {            s += nc            ++ip            nc = text[ip]        }        return s    }    function out(s) {        output.innerHTML += "Line: " + ipToLineNo(ip) + ": " + s + "<br>"    }    function error(s) {        out(s)        throw s    }        var isNum = function(nc) { return (nc >= "0" && nc <= "9") || nc =='-' || nc == '.'}    var isalpha = function(nc) { return (nc >= "a" && nc <= "z") || (nc >= "A" && nc <= "Z") }         var readNum = function() {        var nc = text[ip]        if (isNum(nc))                    return parseFloat(readChars(isNum))        else {            var name = readName()            return getVar(name)        }    }    var readSpace = function() {        readChars( function(nc) { return nc == ' ' || nc == '\n' || nc == '\t' })    }    var readName = function() {        return readChars(isalpha)    }    var readAny = function(s) { // any of the characters in the string given        return readChars(function(nc) { return s.indexOf(nc) >= 0 })    }    var ipToLineNo = function(ip) {        var lno = 1        var n = Math.min(ip, text.length)        for(var i = 0; i < n; ++i)            if (text[i] == '\n')                lno++        return lno        }    var findFirstOf = function(lst, ip) {        var minip = text.length + 1        var found = null        for(i in lst) {            s = lst[i]            var p = text.indexOf(s, ip)            if (p >= 0 && !isalpha(text[p - 1])&& !isalpha(text[p + s.length]) && p < minip) { // it's a whole word, surronded by non letters                minip = p + s.length // return the ip just after what was found                found = s            }        }        return [found, minip]    }        ctx.beginPath();       ctx.moveTo(x, y)        var funcs = {}    var vars = {}    var globals = vars // top level vars are the globals    var getVar = function(name) {        if (name in vars)             return vars[name]        else if (name in globals)            return globals[name]        else            error("Unknown variable " + name)    }    var loopStack = [] // elements are from 'do'    var callStack = [] // elements are from function call, things that are below the current call which is in vars        var startTime = new Date().getTime()    var allocTime = 1000        readSpace()    try {        while (ip < text.length) {            if (new Date().getTime() - startTime > allocTime)                error("too much time")            c = readChars(function(nc) { return isalpha(nc) || '=+-/*#'.indexOf(nc) >= 0 })             if (c[0] == '#') { // comment                ip = text.indexOf('\n', ip)                readSpace()                continue            }            readSpace()            if (c == '')                 error("empty command?")            if (c == 'F' || c == 'Fs' || c == 'B' || c == 'Bs') {                var n = readNum()                if (c[0] == 'B')                    n = -n                x += n * Math.cos(ang * Math.PI / 180.0)                y += n * Math.sin(ang * Math.PI / 180.0)                if (c[1] == 's') // silent                    ctx.moveTo(x, y)                else                    ctx.lineTo(x, y)            }            else if (c == 'T' || c == 'turn') {                ang += readNum()            }            else if (c == 'time') {                allocTime = readNum()            }            else if (c == '=') {                var name = readName()                readSpace()                var num = readNum()                vars[name] = num            }            else if (c == 'neg') {                var name = readName()                vars[name] = -getVar(name)            }            else if ("+-/*".indexOf(c) >= 0) {                var name = readName()                readSpace()                var num = readNum()                if (c == '+')                    vars[name] = getVar(name) + num                if (c == '-')                    vars[name] = getVar(name) - num                else if (c == '/')                    vars[name] = Math.trunc(getVar(name) / num)                else if (c == '*')                    vars[name] = getVar(name) * num            }            else if (c == 'do') {                var times = readNum()                loopStack.push( {"timesLeft":times, "toip":ip} )            }            else if (c == 'next') {                var d = loopStack.pop()                if (d === undefined)                    error("next without do")                --d.timesLeft                if (d.timesLeft > 0) {                    loopStack.push(d)                    ip = d.toip                }            }            else if (c == 'color') {                var r = readNum()                readSpace()                var g = readNum()                readSpace()                var b = readNum()                ctx.stroke()                ctx.beginPath();                ctx.strokeStyle = "rgb(" + r + "," + g + "," + b + ")"                ctx.moveTo(x, y)            }            else if (c == "func") {                var fname = readName()                readSpace()                if (readAny('(') != '(')                     error("func " + name + " missing arguments")                var args = []                while(true) {                    readSpace()                    var aname = readName()                    if (aname.length == 0)                        break                    args.push(aname)                }                readSpace()                if (readAny(')') != ')')                     error("func " + name + " missing arguments close")                var endip = text.indexOf("endf", ip)                if (endip < 0)                     error("no endf for function " + name)                funcs[fname] = { "args":args, "startip":ip, "endip":endip }                ip = endip + 4; // after endf            }            else if (c in funcs) { // function call                var f = funcs[c]                nvars = {}                for(i in f.args) {                    var v = readNum()                    nvars[f.args[i]] = v                }                callStack.push( { "vars": vars, "returnip": ip })                ip = f.startip                vars = nvars            }            else if (c == "endf" || c == "return") {                var fr = callStack.pop()                vars = fr.vars                ip = fr.returnip            }            else if (c == "if") {                var n1 = readNum()                readSpace()                var op = readAny('!=<>')                readSpace()                var n2 = readNum()                var result                switch (op) {                    case '==': result = (n1 == n2); break;                    case '>=': result = (n1 >= n2); break;                    case '<=': result = (n1 <= n2); break;                    case '>': result = (n1 > n2); break;                    case '<': result = (n1 < n2); break;                    case '!=': result = (n1 != n2); break;                    default: error("Unknown operator " + op)                }                // now decide where to go                var nestlvl = 0                var srch = ip                var elseip = null                while (true) {                    r = findFirstOf(["if", "endif", "else"], srch)                    if (r[0] == null)                        error("if without endif")                    srch = r[1]// next search                    if (r[0] == "if")                        ++nestlvl                    else if (r[0] == "else") {                        if (nestlvl == 0)                             elseip = r[1]                    }                    else if (r[0] == "endif") {                        if (nestlvl > 0)                            --nestlvl                        else {                            // if result was true, just continue normally into the if block                            if (!result) {                                if (elseip !== null)                                     ip = elseip                                else                                    ip = r[1]                            }                            break                        }                    }                }            }            else if (c == "endif") { // do nothing            }            else if (c == "else") {                var srch = ip                var nestlvl = 0                while (true) { // skip to the end of the endif in my nesting level                    r = findFirstOf(["if", "endif"], srch)                    if (r[0] == null)                        error("else without endif")                    srch = r[1]                    if (r[0] == "if")                        ++nextlvl                    else if (r[0] == "endif") {                        if (nestlvl > 0)                            --nextlvl                        else {                            ip = r[1]                            break;                        }                    }                }            }            else if (c == "print") {                var n = readNum()                out(n)            }            else {                error("Unknown command `" + c + "`")                            }            readSpace()        }    }    catch(err)    {}    ctx.stroke();    if (loopStack.length != 0)        error("Unbalanded do")}/* Examples= a 5do 1000  F a  T 89  + a 2  = yy a  / yy 2   color 0 a yy next---------func sqr()   do 4      F 100     T 90   nextendfdo 10  sqr()  T 20  F 20next*/</script></head><body onload="init()">  <canvas id="canvas" width="600" height="600" style="border:solid 1px;"></canvas>  <textarea id="text" style="position:absolute; left:650px; top:10px; width:300px; height:600px;" oninput="textChanged()"></textarea>  <div id="output"></div></body></html>